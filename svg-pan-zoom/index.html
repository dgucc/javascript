<!DOCTYPE html>
<html lang="en">

<head>
<meta charset="UTF-8">
<meta name="viewport"
    content="width=device-width, user-scalable=no, initial-scale=1.0, maximum-scale=1.0, minimum-scale=1.0">
<title>Interactive Floor Map</title>
<link rel="stylesheet" href="./styles.css" type="text/css">
</head>

<body>

    <div class="container">
        <svg id="map" width="100%" height="100%" style="background-color:lightgrey">
            <g id="image">
                <image href="world.svg" />
                <!-- <circle fill="red" cx="50" cy="50" r="25" /> -->
            </g>
            
            <g id="preview" transform="translate(20,20) scale(0.2)">
                <image href="world.svg"/>
                <!-- <circle fill="red cx="50" cy="50" r="25" /> -->
            </g>
            <!-- here the minimap viewport will go -->


        </svg>
    </div>

</body>

<script src="./d3.v7.6.1.js"></script>
<script>
// create a D3 selection of the SVG itself
const svg = d3.select("#map");
// create a D3 selection of the image element
const image = svg.selectChild("#image");

const { width, height } = image.node().getBoundingClientRect();

// ===========================================

const zoom = d3.zoom().on("zoom", zoomed);

function updateExtents() {
    const {
        width: svgWidth,
        height: svgHeight
    } = svg.node().getBoundingClientRect();

    const minScale = Math.max(svgWidth / width, svgHeight / height);

    zoom
        // scale extent is how much you can zoom into or out of the image
        .scaleExtent([minScale, 8])
        // extent is mostly used to calculate things and make them smooth during zooming and panning
        // by default it is the viewbox or width and height of the nearest SVG ancestor - this works for us
        .extent([
            [0, 0],
            [svgWidth, svgHeight]
        ])
        // translate extent is optional and is used to bound the viewport to the image
        .translateExtent([
            [0, 0],
            [width, height]
        ]);

    // apply calculated default scale
    zoom.scaleTo(svg, minScale);
}

// ===========================================

const preview = svg.select("#preview");

const rect = preview
    .append("rect")
    .style("fill-opacity", "0")
    .style("stroke", "red")
    .style("stroke-width", "3px");

function updateViewport() {
    const {
        width: svgWidth,
        height: svgHeight
    } = svg.node().getBoundingClientRect();

    rect.attr("width", svgWidth).attr("height", svgHeight);
}

// ===========================================

// apply configured zoom behaviour to our svg
svg.call(zoom);

updateExtents();
updateViewport();

window.addEventListener("resize", updateExtents);
window.addEventListener("resize", updateViewport);

function zoomed(event) {
    const { transform } = event;
    // apply calculated transform to the image
    image.attr("transform", transform.toString());

    const scale = 1 / transform.k;

    const inverseTransform = new d3.ZoomTransform(
        scale,
        -transform.x * scale,
        -transform.y * scale
    );

    rect.attr("transform", inverseTransform.toString());
}

// ===========================================

preview.on("click", handleMinimapClick);

const previewRect = preview.node().getBoundingClientRect();

const PREVIEW_SCALE = 0.1;

function handleMinimapClick(event) {
    const dx = event.clientX - previewRect.x,
        dy = event.clientY - previewRect.y;

    const position = [dx / PREVIEW_SCALE, dy / PREVIEW_SCALE];

    zoom.translateTo(svg, ...position);
}

</script>
</body>

</html>